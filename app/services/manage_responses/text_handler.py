import time
import asyncio
from rich import print
from typing import AsyncGenerator
from googletrans import Translator
from app.schemas.message import Message
from .response_manager import ResponseManager

class TextHandler(ResponseManager):
    """Handler specialized for text-only inputs."""
    
    @classmethod
    async def handle_text_response(cls, input_data: Message = None, user_id: str = None) -> AsyncGenerator[str, None]:
        """
        Handle a user message that contains only text by classifying and routing it to the appropriate responder.

        Args:
            input_data (Message): The user message containing the text input.
            user_id (str): The user's ID, used for retrieving past messages and history.

        Yields:
            AsyncGenerator[str, None]: A stream of generated response tokens from the selected model.

        Raises:
            Exception: If classification or routing fails.
        """        
        try:
            # Classify text
            text_result = await cls._classify_text(input_data)
            print(f"Text classification completed: {text_result}")
            
            # Route based on classification
            return await cls._route_text_response(input_data, text_result, user_id=user_id)
            
        except Exception as e:
            print(f"Text response handling failed: {str(e)}")
            raise Exception(f"Text response failed: {str(e)}")
    
    @classmethod
    async def _classify_text(cls, input_data: Message = None) -> str:
        """
        Translate and classify the user's text input in parallel to determine if it's medical-related or not.

        Args:
            input_data (Message): The user message containing text.

        Returns:
            str: The classification result, typically 'medical-related' or 'not-medical-related'.

        Raises:
            Exception: If translation, classification, or either task fails.
        """
        try:
            async with Translator() as translator:
                translate_task = translator.translate(text=input_data.content, src="auto", dest="en")
                
                classifier_task = cls.get_classifier()

                start_time = time.time()

                # Run both coroutines concurrently
                translated_prompt, classifier = await asyncio.gather(translate_task, classifier_task)
                
            # Classify text
            text_result = await classifier.classify_text(prompt=translated_prompt.text)
            
            cls._log_execution_time(start_time, "Text Classification")
            return text_result
            
        except Exception as e:
            print(f"Text classification failed: {str(e)}")
            raise Exception(f"Text classification failed: {str(e)}")
    
    @classmethod
    async def _route_text_response(cls, input_data: Message = None, text_result: str = None, user_id: str = None) -> AsyncGenerator[str, None]:
        """
        Route a classified text message to either RAG or general LLM pipeline depending on classification.

        Args:
            input_data (Message): The original user message.
            text_result (str): Classification label indicating the nature of the text.
            user_id (str): The user's ID for history/context-aware retrieval.

        Yields:
            AsyncGenerator[str, None]: A stream of tokens generated by the selected model.

        Raises:
            Exception: If the response routing logic fails.
        """
        try:
            is_medical = text_result != "not related to medical" and text_result != "code"
            
            if is_medical:
                # Medical text - use RAG
                return await cls.handle_rag_response(input_data=input_data, collection_name=text_result, user_id=user_id)
            elif text_result == "code":
                # Code-related text - use LLM responder
                return await cls.handle_llm_response(input_data=input_data, user_id=user_id)
            else:
                # Non-medical text - use general LLM
                return await cls.handle_llm_response(input_data=input_data, user_id=user_id)
                
        except Exception as e:
            print(f"Text response routing failed: {str(e)}")
            raise Exception(f"Text response routing failed: {str(e)}")